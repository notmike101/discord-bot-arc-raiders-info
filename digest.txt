Code Digest for Directory: D:\discord-arc-raiders-assistant
Generated: 2025-11-30T06:03:37.246Z

Directory Structure (28 included files shown)
==================================================
├── src/
│   ├── services/
│   │   ├── discord/
│   │   │   ├── commands/
│   │   │   │   ├── ammunition-item.ts
│   │   │   │   ├── augment-item.ts
│   │   │   │   ├── blueprint-item.ts
│   │   │   │   ├── consumable-item.ts
│   │   │   │   ├── cosmetic-item.ts
│   │   │   │   ├── gadget-item.ts
│   │   │   │   ├── item.ts
│   │   │   │   ├── key-item.ts
│   │   │   │   ├── material-item.ts
│   │   │   │   ├── misc-item.ts
│   │   │   │   ├── modification-item.ts
│   │   │   │   ├── nature-item.ts
│   │   │   │   ├── quest-item.ts
│   │   │   │   ├── quick-use-item.ts
│   │   │   │   ├── recycleable-item.ts
│   │   │   │   ├── shield-item.ts
│   │   │   │   ├── throwable-item.ts
│   │   │   │   ├── trinket-item.ts
│   │   │   │   └── weapon-item.ts
│   │   │   ├── generateEmbeds.ts
│   │   │   └── index.ts
│   │   ├── metaforge/
│   │   │   └── index.ts
│   │   └── redis/
│   │       └── index.ts
│   └── utils.ts
├── types/
│   ├── environment.d.ts
│   └── MetaForge.d.ts
├── index.ts
└── package.json


Included File Contents (81.17 KB)
==================================================

### CODEDIGEST_FILE: index.ts ###
import { loadEnvFile } from 'node:process';
import path from 'node:path';
import { DiscordService } from './src/services/discord/index.ts';
import { MetaforgeService } from './src/services/metaforge/index.ts';

loadEnvFile(path.join(import.meta.dirname, '.env'));

process.env.ROOTDIR = import.meta.dirname;

if (!process.env.SYNC_INTERVAL) {
  process.env.SYNC_INTERVAL = '21600';
}

const syncInterval = parseInt(process.env.SYNC_INTERVAL) * 1_000;

process.env.SYNC_INTERVAL = syncInterval.toString();

if (!process.env.DISCORD_TOKEN) {
  throw new Error('No discord token provided');
}

if (!process.env.DISCORD_CLIENT_ID) {
  throw new Error('No discord client ID provided');
}

if (!process.env.DISCORD_GUILD_ID) {
  throw new Error('No discord guild ID provided');
}


const discordService = new DiscordService({
  token: process.env.DISCORD_TOKEN,
  clientId: process.env.DISCORD_CLIENT_ID,
  guildId: process.env.DISCORD_GUILD_ID,
});

const metaforgeService = new MetaforgeService();

await metaforgeService.reloadData();

discordService.initialize();
### CODEDIGEST_END ###

### CODEDIGEST_FILE: package.json ###
{
  "name": "@notmike101/arc-raiders-discord-bot",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "node --watch index.ts",
    "start": "node index.ts",
    "injest": "node src/redisInjest.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "packageManager": "pnpm@10.23.0+sha512.21c4e5698002ade97e4efe8b8b4a89a8de3c85a37919f957e7a0f30f38fbc5bbdd05980ffe29179b2fb6e6e691242e098d945d1601772cad0fef5fb6411e2a4b",
  "dependencies": {
    "discord.js": "^14.25.1",
    "redis": "^5.10.0"
  },
  "devDependencies": {
    "@types/node": "^24.10.1"
  }
}
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/ammunition-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('ammunition-item')
  .setDescription('Look up an ammunition item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.AmmunitionItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.AMMUNITION, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/augment-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('augment-item')
  .setDescription('Look up an augment item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.AugmentItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.AUGMENTS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/blueprint-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('blueprint-item')
  .setDescription('Look up a blueprint item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.BlueprintItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.BLUEPRINTS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/consumable-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('consumable-item')
  .setDescription('Look up a consumable item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.ConsumableItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.CONSUMABLES, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/cosmetic-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('cosmetic-item')
  .setDescription('Look up a cosmetic item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.CosmeticItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.COSMETICS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/gadget-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('gadget-item')
  .setDescription('Look up a gadget item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.GadgetItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.GADGETS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateWeaponEmbed, generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('item')
  .setDescription('Look up an item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const item = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`);

  if (!item) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  if (item.item_type === 'Weapon') {
    embeds.push(generateWeaponEmbed(item));
  } else {
    embeds.push(generateMiscEmbed(item));
  }

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.ALL, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/key-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('key-item')
  .setDescription('Look up a key item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.KeyItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.KEYS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/material-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('material-item')
  .setDescription('Look up a material item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.BasicMaterialItem | MetaForge.RefinedMaterialItem | MetaForge.TopsideMaterialItem | MetaForge.AdvancedMaterialItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.MATERIALS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/misc-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('misc-item')
  .setDescription('Look up a misc item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.MiscItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.MISC, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/modification-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('modification-item')
  .setDescription('Look up a modification item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.ModificationItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.MODIFICATIONS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/nature-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('nature-item')
  .setDescription('Look up a nature item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.NatureItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.NATURE, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/quest-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('quest-item')
  .setDescription('Look up a quest item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.QuestItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.QUESTS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/quick-use-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('quick-use-item')
  .setDescription('Look up a quick use item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.QuickUseItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.QUICK_USE, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/recycleable-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('recyclable-item')
  .setDescription('Look up a recycleable item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.RecyclableItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.RECYCLABLES, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/shield-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('shield-item')
  .setDescription('Look up a shield item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.ShieldItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.SHIELDS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/throwable-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('throwable-item')
  .setDescription('Look up a throwable item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.ThrowableItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.THROWABLES, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/trinket-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateMiscEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('trinket-item')
  .setDescription('Look up a trinket item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.TrinketItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateMiscEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.TRINKETS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/commands/weapon-item.ts ###
import { SlashCommandBuilder, MessageFlags, type EmbedBuilder, type AutocompleteInteraction, type ChatInputCommandInteraction } from 'discord.js';
import { RedisService } from '../../redis/index.ts';
import { generateWeaponEmbed } from '../generateEmbeds.ts';

const redisService = new RedisService();

export const data = new SlashCommandBuilder()
  .setName('weapon-item')
  .setDescription('Look up a weapon item')
  .addStringOption((option) => option
    .setName('identifier')
    .setDescription('Item name')
    .setRequired(true)
    .setAutocomplete(true)
  );

export const execute = async (interaction: ChatInputCommandInteraction) => {
  const info = await redisService.getItemById(`${RedisService.KEYS.PREFIX}${interaction.options.getString('identifier')}`) as MetaForge.WeaponItem;

  if (!info) {
    interaction.reply({
      content: `Item ${interaction.options.getString('identifier')} not found...`,
      flags: MessageFlags.Ephemeral,
    });

    return;
  }

  const embeds: Array<EmbedBuilder> = [];

  embeds.push(generateWeaponEmbed(info));

  interaction.reply({
    embeds,
  });
};

export const autocomplete = async (interaction: AutocompleteInteraction) => {
  const searchQuery = interaction.options.getFocused().toLowerCase();

  if (searchQuery.length <= 2) {
    await interaction.respond([{ name: 'Minimum autocomplete length is 3', value: '' }]);

    return;
  }

  const searchResults = await redisService.search(RedisService.KEYS.WEAPONS, searchQuery, 'name', (data) => data.toLowerCase());
  const options: Array<{ name: string, value: string }> = [];

  for (const searchResult of searchResults) {
    options.push({ name: searchResult.name, value: searchResult.id });
  }

  options.sort((a, b) => a.name.localeCompare(b.name))

  await interaction.respond(options);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/generateEmbeds.ts ###
import { EmbedBuilder } from 'discord.js';
import { camelCaseToTitleCase } from '../../utils.ts';

export const generateMiscEmbed = (item: MetaForge.ARCItem) => {
  const embed = new EmbedBuilder();

  embed.setTitle(item.name);

  if (item.icon) {
    embed.setThumbnail(item.icon);
  }

  embed.addFields([
    { name: 'Type', value: `${item.item_type}${item.subcategory ? `/${item.subcategory}` : ''}`, inline: true },
    { name: 'Rarity', value: item.rarity, inline: true },
    { name: 'Value', value: `${item.value.toLocaleString()} credits`, inline: true },
    { name: 'Weight', value: `${item.stat_block.weight} kg`, inline: true },
  ]);

  let itemDescription = `${item.description} ${item.flavor_text}`;

  if (item.components && item.components.length > 0) {
    itemDescription += `\n### Crafting Recipe:\n${item.components.map((elm) => `* ${elm.component.name} x${elm.quantity}`).join('\n')}`;
  }

  if (item.recycle_components && item.recycle_components.length > 0) {
    itemDescription += `\n\n**Recycles Into**:\n${item.recycle_components.map((elm) => `* ${elm.component.name} x${elm.quantity}`).join('\n')}`
  }

  if (item.used_in && Object.keys(item.used_in).length > 0) {
    itemDescription += `\n\n**Used To Craft**:\n${Object.values(item.used_in).map((elm) => `* ${elm.item.name}`).join('\n')}`;
  }

  if (item.sold_by && item.sold_by.length > 0) {
    itemDescription += `\n\n**Sold By**:\n${item.sold_by.map((elm) => `${elm.trader_name}: ${elm.price.toLocaleString()}`)}`
  }

  /*
  if (item.stat_block && Object.keys(item.stat_block).length > 0) {
    const blocks: Array<Array<string>> = [];
    let blockIndex = 0;
    const entries = Object.entries(item.stat_block);
    const finalizedLines: Array<string> = [];
    const lineLimit = 2;

    for (let i = 1; i <= entries.length; ++i) {
      if (!blocks[blockIndex]) {
        blocks[blockIndex] = [];
      }

      blocks[blockIndex].push(`**${camelCaseToTitleCase(entries[i - 1][0])}**: ${entries[i - 1][1]}`);

      if (i % lineLimit === 0) {
        finalizedLines.push(blocks[blockIndex].join('   '));
        blockIndex++;
      }
    }

    itemDescription += `\n\n**Stats**:\n${finalizedLines.join('\n')}`
  }
  */

  embed.setDescription(itemDescription);

  embed.setURL(`https://metaforge.app/arc-raiders/database/item/${item.id}`);
  embed.setAuthor({
    name: 'MetaForge',
    url: 'https://metaforge.app/arc-raiders/',
  });

  embed.setTimestamp(new Date(item.updated_at));

  embed.setFooter({
    text: `Last updated`,
  });

  return embed;
};

export const generateWeaponEmbed = (item: MetaForge.WeaponItem) => {
  const embed = new EmbedBuilder();

  embed.setTitle(item.name);

  if (item.icon) {
    embed.setThumbnail(item.icon);
  }

  embed.addFields([
    { name: 'Type', value: `${item.item_type}/${item.subcategory}/${item.ammo_type}`, inline: true },
    { name: 'Rarity', value: item.rarity, inline: true },
    { name: 'Value', value: `${item.value.toLocaleString()} credits`, inline: true },
    { name: 'Weight', value: `${item.stat_block.weight} kg`, inline: true },
  ]);

  embed.addFields(
    { name: 'Firing Mode', value: item.stat_block.firingMode, inline: true },
    { name: 'Fire Rate', value: item.stat_block.fireRate.toString(), inline: true },
    { name: 'Stability', value: item.stat_block.stability.toString(), inline: true },
    { name: 'Damage', value: item.stat_block.damage.toString(), inline: true },
    { name: 'Range', value: item.stat_block.range.toString(), inline: true },
    { name: 'Stability', value: item.stat_block.stability.toString(), inline: true },
  );

  let itemDescription = `${item.description} ${item.flavor_text}`;

  if (item.components && item.components.length > 0) {
    itemDescription += `\n### Crafting Recipe:\n${item.components.map((elm) => `* ${elm.component.name} x${elm.quantity}`).join('\n')}`;
  }

  if (item.recycle_components && item.recycle_components.length > 0) {
    itemDescription += `\n\n**Recycles Into**:\n${item.recycle_components.map((elm) => `* ${elm.component.name} x${elm.quantity}`).join('\n')}`
  }

  if (item.used_in && Object.keys(item.used_in).length > 0) {
    itemDescription += `\n\n**Used To Craft**:\n${Object.values(item.used_in).map((elm) => `* ${elm.item.name}`).join('\n')}`;
  }

  if (item.mods && item.mods.length > 0) {
    itemDescription += `\n\n**Available Mods**:\n${item.mods.map((elm) => `* ${elm.mod.name}`).join('\n')}`;
  }

  if (item.sold_by && item.sold_by.length > 0) {
    itemDescription += `\n\n**Sold By**:\n${item.sold_by.map((elm) => `${elm.trader_name}: ${elm.price.toLocaleString()}`)}`
  }

  embed.setDescription(itemDescription);

  embed.setURL(`https://metaforge.app/arc-raiders/database/item/${item.id}`);
  embed.setAuthor({
    name: 'MetaForge',
    url: 'https://metaforge.app/arc-raiders/',
  });

  embed.setTimestamp(new Date(item.updated_at));

  embed.setFooter({
    text: `Last updated`,
  });

  return embed;
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/discord/index.ts ###
import fs from 'node:fs';
import path from 'node:path';
import url from 'node:url';
import { Client, GatewayIntentBits, Collection, Events, Routes, REST, MessageFlags, type ChatInputCommandInteraction, type AutocompleteInteraction, type Interaction, type CacheType, SlashCommandBuilder } from 'discord.js';

export class DiscordService {
  #client: Client;
  #rest: REST;
  #token: string;
  #clientId: string;
  #guildId: string;
  #initialized = false;
  #commands = new Collection<string, { execute: (interaction: ChatInputCommandInteraction) => Promise<void>; autocomplete: (interaction: AutocompleteInteraction) => Promise<void>, data: SlashCommandBuilder }>();

  constructor({ token, clientId, guildId }: { token: string, clientId: string, guildId: string}) {
    if (!token) {
      throw new Error('Discord bot token not provided.');
    }

    if (!clientId) {
      throw new Error('Discord bot client ID not provided.');
    }

    if (!guildId) {
      throw new Error('Discord bot guilt ID not provided');
    }

    this.#token = token;
    this.#clientId = clientId;
    this.#guildId = guildId;

    this.#client = new Client({
      intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
      ],
    });

    this.#rest = new REST({ version: '10' }).setToken(this.#token);

    this.#client.on(Events.InteractionCreate, this.#handleInteractionCreate.bind(this) as (interaction: Interaction<CacheType>) => void);
  }

  async initialize() {
    if (this.#initialized === true) {
      console.warn('Already initialized, skipping');

      return;
    }

    try {
      this.#client.login(this.#token);
      
      await this.#registerCommands();
    } catch (err) {
      console.error(err);
    }
  }

  async #registerCommands() {
    const commandsPath = path.join(import.meta.dirname, 'commands');
    const commandFiles = fs.readdirSync(commandsPath).filter((file) => file.endsWith('.ts'));

    for (const commandFile of commandFiles) {
      const filePath = path.join(commandsPath, commandFile);
      const command = await import(url.pathToFileURL(filePath).toString());

      if ('data' in command && 'execute' in command) {
        this.#commands.set(command.data.name, command);
      } else {
        console.log(`[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`);
      }
    }

    try {
      this.#rest.put(Routes.applicationGuildCommands(this.#clientId, this.#guildId), { body: [...this.#commands.values()].map((entry) => entry.data.toJSON()) });
    } catch(err) {
      console.error(err);
    }
  }

  async #handleInteractionCreate(interaction: ChatInputCommandInteraction | AutocompleteInteraction) {
    const command = this.#commands.get(interaction.commandName);

    if (!command) {
      return;
    }

    if (interaction.isChatInputCommand()) {
      try {
        await command.execute(interaction);
      } catch (err) {
        console.error(err);

        await interaction[(interaction.replied || interaction.deferred) ? 'followUp' : 'reply']({
          content: 'There was an error while executing this command...',
          flags: MessageFlags.Ephemeral,
        });
      }
    } else if (interaction.isAutocomplete()) {
      try {
        await command.autocomplete(interaction);
      } catch (err) {
        console.error(err);
      }
    }
  }
}
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/metaforge/index.ts ###
import { RedisService } from '../redis/index.ts';

const redisService = new RedisService();

export class MetaforgeService {
    protected API_ENDPOINT = 'https://metaforge.app/api/arc-raiders/items';

    static BLACKLIST_ITEM_IDS = ['refinement-1'];

    constructor() {
        setTimeout(() => {
            this.reloadData();
        }, parseInt(process.env.SYNC_INTERVAL));
    }

    public normalizeItem(item: MetaForge.ARCItem): MetaForge.ARCItem {
        if (item.ammo_type) {
            item.ammo_type = item.ammo_type.toLowerCase();
        }

        if (item.item_type === 'Weapon' && !item.stat_block.firingMode) {
            item.stat_block.firingMode = 'Unknown';
        }

        return item;
    }

    public async reloadData() {
        this.loadDataIntoRedis();
    }

    protected async fetchAllData(): Promise<Array<MetaForge.ARCItem>> {
        let allItems: Array<MetaForge.ARCItem> = [];
        let page = 1;
        let hasNext = true;
        const backoffDelay = 200;

        while (hasNext) {
            try {
                const res = await fetch(`${this.API_ENDPOINT}?page=${page}&limit=100&includeComponents=true`);
                const resJSON = await res.json();
                const { data, pagination } = resJSON;

                allItems = [...allItems, ...data];

                hasNext = pagination.hasNextPage;
                page++;

                await new Promise((resolve) => setTimeout(resolve, backoffDelay));
            } catch (err) {
                console.error(`  Failed on page ${page}`);
                throw err;
            }
        }

        return allItems;
    }

    private async loadDataIntoRedis() {
        await redisService.connect();
        await redisService.reset();

        try {
            const rawItems = await this.fetchAllData();
            const multi = redisService.client.multi();

            for (const raw of rawItems) {
                const item = this.normalizeItem(raw);
                const key = `${RedisService.KEYS.PREFIX}${item.id}`;

                if (MetaforgeService.BLACKLIST_ITEM_IDS.includes(item.id)) {
                    continue;
                }

                multi.set(key, JSON.stringify(item));
                multi.sAdd(RedisService.KEYS.ALL, item.id);

                switch (item.item_type) {
                    case 'Weapon':
                        multi.sAdd(RedisService.KEYS.WEAPONS, item.id);
                        break;
                    case 'Consumable':
                        multi.sAdd(RedisService.KEYS.CONSUMABLES, item.id);
                        break;
                    case 'Quick Use':
                        multi.sAdd(RedisService.KEYS.QUICK_USE, item.id);
                        break;
                    case 'Throwable':
                        multi.sAdd(RedisService.KEYS.THROWABLES, item.id);
                        break;
                    case 'Ammunition':
                        multi.sAdd(RedisService.KEYS.AMMUNITION, item.id);
                        break;
                    case 'Modification':
                        multi.sAdd(RedisService.KEYS.MODIFICATIONS, item.id);
                        break;
                    case 'Blueprint':
                        multi.sAdd(RedisService.KEYS.BLUEPRINTS, item.id);
                        break;
                    case 'Shield':
                        multi.sAdd(RedisService.KEYS.SHIELDS, item.id);
                        break;
                    case 'Augment':
                        multi.sAdd(RedisService.KEYS.AUGMENTS, item.id);
                        break;
                    case 'Gadget':
                        multi.sAdd(RedisService.KEYS.GADGETS, item.id);
                        break;
                    case 'Key':
                        multi.sAdd(RedisService.KEYS.KEYS, item.id);
                        break;
                    case 'Quest Item':
                        multi.sAdd(RedisService.KEYS.QUESTS, item.id);
                        break;
                    case 'Cosmetic':
                        multi.sAdd(RedisService.KEYS.COSMETICS, item.id);
                        break;
                    case 'Topside Material':
                        multi.sAdd(RedisService.KEYS.TOPSIDE_MATERIALS, item.id);
                        multi.sAdd(RedisService.KEYS.MATERIALS, item.id);
                        break;
                    case 'Basic Material':
                        multi.sAdd(RedisService.KEYS.BASIC_MATERIALS, item.id);
                        multi.sAdd(RedisService.KEYS.MATERIALS, item.id);
                        break;
                    case 'Refined Material':
                        multi.sAdd(RedisService.KEYS.REFINED_MATERIALS, item.id);
                        multi.sAdd(RedisService.KEYS.MATERIALS, item.id);
                        break;
                    case 'Advanced Material':
                        multi.sAdd(RedisService.KEYS.ADVANCED_MATERIALS, item.id);
                        multi.sAdd(RedisService.KEYS.MATERIALS, item.id);
                        break;
                    case 'Recyclable':
                        multi.sAdd(RedisService.KEYS.RECYCLABLES, item.id);
                        break;
                    case 'Nature':
                        multi.sAdd(RedisService.KEYS.NATURE, item.id);
                        break;
                    case 'Trinket':
                        multi.sAdd(RedisService.KEYS.TRINKETS, item.id);
                        break;
                    case 'Misc':
                        multi.sAdd(RedisService.KEYS.MISC, item.id);
                        break;
                }
            };

            await multi.exec();
        } catch (err) {
            console.error('Fatal Error:', err);
        } finally {
            redisService.disconnect();
        }
    }
}
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/services/redis/index.ts ###
import { createClient, type RedisClientType } from 'redis';

export class RedisService {
    public client: RedisClientType;

    public static KEYS = {
        PREFIX: 'arc:item:',
        ALL: 'arc:index:all-items',
        WEAPONS: 'arc:index:weapon-items',
        CONSUMABLES: 'arc:index:consumable-items',
        QUICK_USE: 'arc:index:quick-use-items',
        THROWABLES: 'arc:index:throwable-items',
        AMMUNITION: 'arc:index:ammunition-items',
        MODIFICATIONS: 'arc:index:modification-items',
        BLUEPRINTS: 'arc:index:blueprint-items',
        SHIELDS: 'arc:index:shield-items',
        AUGMENTS: 'arc:index:augment-items',
        GADGETS: 'arc:index:gadget-items',
        KEYS: 'arc:index:key-items',
        QUESTS: 'arc:index:quest-items',
        COSMETICS: 'arc:index:cosmetic-items',
        MATERIALS: 'arc:index:material-items',
        TOPSIDE_MATERIALS: 'arc:index:topside-material-items',
        BASIC_MATERIALS: 'arc:index:basic-material-items',
        REFINED_MATERIALS: 'arc:index:refined-material-items',
        ADVANCED_MATERIALS: 'arc:index:advanced-material-items',
        RECYCLABLES: 'arc:index:recyclable-items',
        NATURE: 'arc:index:nature-items',
        TRINKETS: 'arc:index:trinket-items',
        MISC: 'arc:index:misc-items',

    };

    constructor(url: string = process.env.REDIS_URL || 'redis://localhost:6379') {
        this.client = createClient({ url });

        this.client.on('error', (err) => {
            console.error('Redis service error', err);
        });

        this.connect();
    }

    get connected () {
        return this.client.isOpen;
    }

    public async connect() {
        if (!this.client.isOpen) {
            await this.client.connect();
        }
    }

    public async disconnect() {
        if (this.client.isOpen) {
            await this.client.close();
        }
    }

    private async clearIndexes() {
        await this.client.del(Object.values(RedisService.KEYS));
    }

    private async flushdb() {
        await this.client.flushAll();
    }

    public async reset() {
        await this.clearIndexes();
        await this.flushdb();
    }

    public async getCount(id: string) {
        const key = `${RedisService.KEYS.PREFIX}${id}`;

        return await this.client.sCard(key)
    }

    public async getItemById(id: string): Promise<MetaForge.ARCItem | null> {
        if (!id.startsWith(RedisService.KEYS.PREFIX)) {
            id = `${RedisService.KEYS.PREFIX}${id}`;
        }

        const item = await this.client.get(id);

        if (!item) return null;

        try {
            return JSON.parse(item) as MetaForge.ARCItem;
        } catch {
            return null;
        }
    }

    public async getItemsByType(type: keyof typeof RedisService.KEYS | string): Promise<Array<MetaForge.ARCItem>> {
        let indexKey;

        if (type in RedisService.KEYS) {
            indexKey = RedisService.KEYS[type as keyof typeof RedisService.KEYS];
        } else {
            indexKey = type;
        }

        const ids = await this.client.sMembers(indexKey);
        const itemKeys: Array<string> = [];

        for (const id of ids) {
            itemKeys.push(`${RedisService.KEYS.PREFIX}${id}`);
        }
        
        const results = await this.client.mGet(itemKeys);
        const output: Array<MetaForge.ARCItem> = [];
        
        for (const jsonString of results) {
            if (!jsonString) continue;

            try {
                const item = JSON.parse(jsonString);

                output.push(item);
            } catch {
                console.warn('Skipping malfored JSON');
            }
        }

        return output;
    }

    public async search(type: keyof typeof RedisService.KEYS | string, query: any, queryField: keyof MetaForge.ARCItem = 'id', handler?: (data: any) => typeof data): Promise<Array<MetaForge.ARCItem>> {
        const allType = await this.getItemsByType(type);
        const output: Array<MetaForge.ARCItem> = [];

        for (const item of allType) {
            if (!(queryField in item)) continue;

            const fieldData = handler ? handler(item[queryField]) : item[queryField];

            if (typeof fieldData === 'string' && fieldData.startsWith(query)) {
                output.push(item);
            } else if (typeof fieldData === typeof query && fieldData === query) {
                output.push(item);
            }
        }

        return output;
    }
}

export const redisService = new RedisService();
### CODEDIGEST_END ###

### CODEDIGEST_FILE: src/utils.ts ###
export const stringToTitleCase = (input: string): string => {
  if (typeof input !== 'string') {
    return input;
  }

  return input
    .toLowerCase()
    .split(/\s+/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
};

export const camelCaseToTitleCase = (input: string): string => {
  if (typeof input !== 'string') {
    return input;
  }

  const intermStep = input.replace(/([A-Z])/g, ' $1');

  return intermStep.charAt(0).toUpperCase() + intermStep.slice(1);
};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: types/environment.d.ts ###
declare global {
  namespace NodeJS {
    interface ProcessEnv {
      readonly DISCORD_TOKEN: string;
      readonly DISCORD_CLIENT_ID: string;
      readonly DISCORD_GUILD_ID: string;
      readonly GITHUB_API_TOKEN: string;
      ROOTDIR: string;
      REDIS_URL: string;
      SYNC_INTERVAL: string;
    }
  }
}

export {};
### CODEDIGEST_END ###

### CODEDIGEST_FILE: types/MetaForge.d.ts ###
declare global {
    namespace MetaForge {
        interface StatBlock {
            range: number;
            damage: number;
            health: number;
            radius: number;
            shield: number;
            weight: number;
            agility: number;
            arcStun: number;
            healing: number;
            stamina: number;
            stealth: number;
            useTime: number;
            duration: number;
            fireRate: number;
            firingMode: string;
            stability: number;
            stackSize: number;
            damageMult: number;
            raiderStun: number;
            weightLimit: number;
            augmentSlots?: number; // Optional in some contexts, but present in JSON
            healingSlots?: number;
            magazineSize: number;
            reducedNoise: number;
            shieldCharge: number;
            backpackSlots: number;
            quickUseSlots: number;
            damagePerSecond: number;
            movementPenalty: number;
            safePocketSlots: number;
            damageMitigation: number;
            healingPerSecond: number;
            reducedEquipTime: number;
            staminaPerSecond: number;
            increasedADSSpeed: number;
            increasedFireRate: number;
            reducedReloadTime: number;
            illuminationRadius?: number;
            increasedEquipTime: number;
            reducedUnequipTime: number;
            shieldCompatibility: string | number; // JSON shows "" (string) and 0 (number)
            increasedUnequipTime: number;
            reducedVerticalRecoil: number;
            increasedBulletVelocity: number;
            increasedVerticalRecoil: number;
            reducedMaxShotDispersion: number;
            reducedPerShotDispersion: number;
            reducedDurabilityBurnRate: number | null; // Can be null in JSON
            reducedRecoilRecoveryTime: number;
            increasedRecoilRecoveryTime: number;
            reducedDispersionRecoveryTime: number;
        }

        interface BaseItem {
            id: string;
            name: string;
            description: string;
            loadout_slots: Array<string>;
            icon: string;
            rarity: "Common" | "Uncommon" | "Rare" | "Epic" | "Legendary" | "";
            value: number;
            workbench: string | null;
            flavor_text: string | null;
            created_at: string;
            updated_at: string;
            shield_type: string | null;
            loot_area: string | null;
            sources: Array<string> | null;
            locations: Array<string>;
            components: Array<{
                quantity: number;
                component: {
                    id: string;
                    icon: string;
                    name: string;
                    rarity: string;
                    item_type: string;
                }
            }>;
            used_in: Array<{
                item: {
                    id: string;
                    icon: string;
                    name: string;
                    rarity: string;
                    item_type: string;
                    description: string;
                };
                quantity: number;
            }>;
            recycle_components: Array<{
                quantity: number;
                component: {
                    id: string;
                    icon: string;
                    name: string;
                    rarity: string;
                    item_type: string;
                    description: string;
                }
            }>;
            recycle_from: Array<{
                item: {
                    id: string;
                    icon: string;
                    name: string;
                    rarity: string;
                    item_type: string;
                    description: string;
                };
                quantity: number;
            }>;
            dropped_by: Array<{
                id: string;
                arc: {
                    id: string;
                    icon: string;
                    name: string;
                    description: string;
                };
                arc_id: string;
                created_at: string;
            }>;
            sold_by: Array<{
                price: number;
                trader_name: string;
            }>;
        }

        interface WeaponItem extends BaseItem {
            item_type: 'Weapon';
            loadout_slots: Array<'weapon'>;
            ammo_type: string;
            subcategory: string;
            stat_block: Pick<StatBlock, 
                'firingMode' | 'range' | 'damage' | 'health' | 'radius' | 'shield' |
                'weight' | 'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' |
                'useTime' | 'duration' | 'fireRate' | 'stability' | 'stackSize' |
                'damageMult' | 'raiderStun' | 'weightLimit' | 'augmentSlots' |
                'healingSlots' | 'magazineSize' | 'reducedNoise' | 'shieldCharge' |
                'backpackSlots' | 'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' |
                'safePocketSlots' | 'damageMitigation' | 'healingPerSecond' |
                'reducedEquipTime' | 'staminaPerSecond' | 'increasedADSSpeed' |
                'increasedFireRate' | 'reducedReloadTime' | 'shieldCompatibility' |
                'increasedUnequipTime' | 'reducedVerticalRecoil' |
                'increasedBulletVelocity' | 'reducedMaxShotDispersion' |
                'reducedPerShotDispersion' | 'reducedDurabilityBurnRate' |
                'reducedRecoilRecoveryTime'
            >;
            mods: Array<{
                mod: {
                    id: string;
                    icon: string;
                    name: string;
                    rarity: string;
                    item_type: string;
                }
            }>;
        }

        interface AmmunitionItem extends BaseItem {
            item_type: 'Ammunition',
            ammo_type: null | '';
            subcategory: null | '';
            loadout_slots: Array<'backpack' | 'safePocket'>;
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'radius' | 'shield' | 'weight' | 'agility' |
                'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'damageMult' |
                'raiderStun' | 'weightLimit' | 'shieldCharge' | 'backpackSlots' |
                'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' |
                'safePocketSlots' | 'damageMitigation' | 'healingPerSecond' |
                'reducedEquipTime' | 'staminaPerSecond' | 'increasedADSSpeed' |
                'increasedFireRate' | 'reducedReloadTime' | 'reducedUnequipTime' |
                'shieldCompatibility' | 'reducedVerticalRecoil' | 'increasedVerticalRecoil' |
                'reducedDurabilityBurnRate' | 'increasedRecoilRecoveryTime'
            >;
        }

        interface ModificationItem extends BaseItem {
            item_type: 'Modification';
            ammo_type: null | '';
            subcategory: null | '';
            loadout_slots: Array<'backpack' | 'safePocket'>;
            stat_block: Pick<StatBlock,
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' |
                'useTime' | 'duration' | 'fireRate' | 'stability' | 'stackSize' |
                'damageMult' | 'raiderStun' | 'weightLimit' | 'magazineSize' |
                'reducedNoise' | 'shieldCharge' | 'backpackSlots' | 'quickUseSlots' |
                'damagePerSecond' | 'movementPenalty' | 'safePocketSlots' |
                'damageMitigation' | 'healingPerSecond' | 'reducedEquipTime' |
                'staminaPerSecond' | 'increasedADSSpeed' | 'increasedFireRate' |
                'reducedReloadTime' | 'illuminationRadius' | 'increasedEquipTime' |
                'reducedUnequipTime' | 'shieldCompatibility' | 'increasedUnequipTime' |
                'reducedVerticalRecoil' | 'increasedBulletVelocity' |
                'increasedVerticalRecoil' | 'reducedMaxShotDispersion' |
                'reducedPerShotDispersion' | 'reducedDurabilityBurnRate' |
                'reducedRecoilRecoveryTime' | 'increasedRecoilRecoveryTime' |
                'reducedDispersionRecoveryTime'
            >;
        }

        interface BlueprintItem extends BaseItem {
            item_type: 'Blueprint';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' |
                'useTime' | 'duration' | 'fireRate' | 'stability' | 'stackSize' |
                'damageMult' | 'raiderStun' | 'weightLimit' | 'augmentSlots' |
                'healingSlots' | 'magazineSize' | 'reducedNoise' | 'shieldCharge' |
                'backpackSlots' | 'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' |
                'safePocketSlots' | 'damageMitigation' | 'healingPerSecond' |
                'reducedEquipTime' | 'staminaPerSecond' | 'increasedADSSpeed' |
                'increasedFireRate' | 'reducedReloadTime' | 'illuminationRadius' |
                'increasedEquipTime' | 'reducedUnequipTime' | 'shieldCompatibility' |
                'increasedUnequipTime' | 'reducedVerticalRecoil' | 'increasedBulletVelocity' |
                'increasedVerticalRecoil' | 'reducedMaxShotDispersion' |
                'reducedPerShotDispersion' | 'reducedDurabilityBurnRate' |
                'reducedRecoilRecoveryTime' | 'increasedRecoilRecoveryTime' |
                'reducedDispersionRecoveryTime'
            >;
        }

        interface QuickUseItem extends BaseItem {
            item_type: 'Quick Use';
            ammo_type: null | '';
            subcategory: null | '';
            loadout_slots: Array<'backpack' | 'quickUse' | 'safePocket'>;
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'radius' | 'shield' | 'weight' | 'agility' |
                'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'damageMult' |
                'raiderStun' | 'weightLimit' | 'shieldCharge' | 'backpackSlots' |
                'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' | 'safePocketSlots' |
                'damageMitigation' | 'healingPerSecond' | 'reducedEquipTime' |
                'staminaPerSecond' | 'increasedADSSpeed' | 'increasedFireRate' |
                'reducedReloadTime' | 'reducedUnequipTime' | 'shieldCompatibility' |
                'reducedVerticalRecoil' | 'increasedVerticalRecoil' | 'reducedDurabilityBurnRate' |
                'increasedRecoilRecoveryTime'
            >;
        }

        interface ConsumableItem extends BaseItem {
            item_type: 'Consumable';
            ammo_type: null | '';
            subcategory: null | '';
            loadout_slots: Array<'backpack' | 'quickUse' | 'safePocket'>;
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'radius' | 'shield' | 'weight' | 'agility' |
                'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'raiderStun' |
                'damagePerSecond' | 'healingPerSecond' | 'increasedFireRate' |
                'reducedReloadTime' | 'reducedDurabilityBurnRate'
            >;
        }

        interface ThrowableItem extends BaseItem {
            item_type: 'Throwable',
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'damageMult' |
                'raiderStun' | 'weightLimit' | 'augmentSlots' | 'healingSlots' |
                'magazineSize' | 'reducedNoise' | 'shieldCharge' | 'backpackSlots' |
                'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' | 'safePocketSlots' |
                'damageMitigation' | 'healingPerSecond' | 'reducedEquipTime' |
                'staminaPerSecond' | 'increasedADSSpeed' | 'increasedFireRate' |
                'reducedReloadTime' | 'illuminationRadius' | 'increasedEquipTime' |
                'reducedUnequipTime' | 'shieldCompatibility' | 'increasedUnequipTime' |
                'reducedVerticalRecoil' | 'increasedBulletVelocity' |
                'increasedVerticalRecoil' | 'reducedMaxShotDispersion' |
                'reducedPerShotDispersion' | 'reducedDurabilityBurnRate' |
                'reducedRecoilRecoveryTime' | 'increasedRecoilRecoveryTime' |
                'reducedDispersionRecoveryTime'
            >;
        }

        interface TopsideMaterialItem extends BaseItem {
            item_type: 'Topside Material';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' |
                'useTime' | 'duration' | 'fireRate' | 'stability' | 'stackSize' |
                'damageMult' | 'raiderStun' | 'weightLimit' | 'augmentSlots' |
                'healingSlots' | 'magazineSize' | 'reducedNoise' | 'shieldCharge' |
                'backpackSlots' | 'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' |
                'safePocketSlots' | 'damageMitigation' | 'healingPerSecond' |
                'reducedEquipTime' | 'staminaPerSecond' | 'increasedADSSpeed' |
                'increasedFireRate' | 'reducedReloadTime' | 'illuminationRadius' |
                'increasedEquipTime' | 'reducedUnequipTime' | 'shieldCompatibility' |
                'increasedUnequipTime' | 'reducedVerticalRecoil' | 'increasedBulletVelocity' |
                'increasedVerticalRecoil' | 'reducedMaxShotDispersion' |
                'reducedPerShotDispersion' | 'reducedDurabilityBurnRate' |
                'reducedRecoilRecoveryTime' | 'increasedRecoilRecoveryTime' |
                'reducedDispersionRecoveryTime'
            >;
        }

        interface RefinedMaterialItem extends BaseItem {
            item_type: 'Refined Material';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'damageMult' |
                'raiderStun' | 'weightLimit' | 'augmentSlots' | 'healingSlots' |
                'magazineSize' | 'reducedNoise' | 'shieldCharge' | 'backpackSlots' |
                'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' | 'safePocketSlots' |
                'damageMitigation' | 'healingPerSecond' | 'reducedEquipTime' |
                'staminaPerSecond' | 'increasedADSSpeed' | 'increasedFireRate' |
                'reducedReloadTime' | 'illuminationRadius' | 'increasedEquipTime' |
                'reducedUnequipTime' | 'shieldCompatibility' | 'increasedUnequipTime' |
                'reducedVerticalRecoil' | 'increasedBulletVelocity' |
                'increasedVerticalRecoil' | 'reducedMaxShotDispersion' |
                'reducedPerShotDispersion' | 'reducedDurabilityBurnRate' |
                'reducedRecoilRecoveryTime' | 'increasedRecoilRecoveryTime' |
                'reducedDispersionRecoveryTime'
            >;
        }

        interface AdvancedMaterialItem extends BaseItem {
            item_type: 'Advanced Material';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'damageMult' |
                'raiderStun' | 'weightLimit' | 'magazineSize' | 'reducedNoise' |
                'shieldCharge' | 'backpackSlots' | 'quickUseSlots' | 'damagePerSecond' |
                'movementPenalty' | 'safePocketSlots' | 'damageMitigation' |
                'healingPerSecond' | 'reducedEquipTime' | 'staminaPerSecond' |
                'increasedADSSpeed' | 'increasedFireRate' | 'reducedReloadTime' |
                'illuminationRadius' | 'increasedEquipTime' | 'reducedUnequipTime' |
                'shieldCompatibility' | 'increasedUnequipTime' | 'reducedVerticalRecoil' |
                'increasedBulletVelocity' | 'increasedVerticalRecoil' |
                'reducedMaxShotDispersion' | 'reducedPerShotDispersion' |
                'reducedDurabilityBurnRate' | 'reducedRecoilRecoveryTime' |
                'increasedRecoilRecoveryTime' | 'reducedDispersionRecoveryTime'
            >;
        }

        interface BasicMaterialItem extends BaseItem {
            item_type: 'Basic Material';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: StatBlock;
        }

        interface RecyclableItem extends BaseItem {
            item_type: 'Recyclable';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock,
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'damageMult' |
                'raiderStun' | 'weightLimit' | 'magazineSize' | 'reducedNoise' |
                'shieldCharge' | 'backpackSlots' | 'quickUseSlots' | 'damagePerSecond' |
                'movementPenalty' | 'safePocketSlots' | 'damageMitigation' |
                'healingPerSecond' | 'reducedEquipTime' | 'staminaPerSecond' |
                'increasedADSSpeed' | 'increasedFireRate' | 'reducedReloadTime' |
                'illuminationRadius' | 'increasedEquipTime' | 'reducedUnequipTime' |
                'shieldCompatibility' | 'increasedUnequipTime' | 'reducedVerticalRecoil' |
                'increasedBulletVelocity' | 'increasedVerticalRecoil' |
                'reducedMaxShotDispersion' | 'reducedPerShotDispersion' |
                'reducedDurabilityBurnRate' | 'reducedRecoilRecoveryTime' |
                'increasedRecoilRecoveryTime' | 'reducedDispersionRecoveryTime'
            >;
        }

        interface NatureItem extends BaseItem {
            item_type: 'Nature';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'radius' | 'shield' | 'weight' | 'agility' |
                'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'damageMult' |
                'raiderStun' | 'weightLimit' | 'shieldCharge' | 'backpackSlots' |
                'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' | 'safePocketSlots'
                | 'damageMitigation' | 'healingPerSecond' | 'reducedEquipTime' |
                'staminaPerSecond' | 'increasedADSSpeed' | 'increasedFireRate' |
                'reducedReloadTime' | 'reducedUnequipTime' | 'shieldCompatibility' |
                'reducedVerticalRecoil' | 'increasedVerticalRecoil' | 'reducedDurabilityBurnRate' |
                'increasedRecoilRecoveryTime'
            >;
        }

        interface TrinketItem extends BaseItem {
            item_type: 'Trinket';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock, 
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' | 'useTime' |
                'duration' | 'fireRate' | 'stability' | 'stackSize' | 'damageMult' |
                'raiderStun' | 'weightLimit' | 'augmentSlots' | 'healingSlots' |
                'magazineSize' | 'reducedNoise' | 'shieldCharge' | 'backpackSlots' |
                'quickUseSlots' | 'damagePerSecond' | 'movementPenalty' |
                'safePocketSlots' | 'damageMitigation' | 'healingPerSecond' |
                'reducedEquipTime' | 'staminaPerSecond' | 'increasedADSSpeed' |
                'increasedFireRate' | 'reducedReloadTime' | 'illuminationRadius' |
                'increasedEquipTime' | 'reducedUnequipTime' | 'shieldCompatibility' |
                'increasedUnequipTime' | 'reducedVerticalRecoil' | 'increasedBulletVelocity' |
                'increasedVerticalRecoil' | 'reducedMaxShotDispersion' |
                'reducedPerShotDispersion' | 'reducedDurabilityBurnRate' |
                'reducedRecoilRecoveryTime' | 'increasedRecoilRecoveryTime' |
                'reducedDispersionRecoveryTime'
            >;
        }

        interface KeyItem extends BaseItem {
            item_type: 'Key';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: StatBlock;
        }

        interface ShieldItem extends BaseItem {
            item_type: 'Shield';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: StatBlock;
        }

        interface AugmentItem extends BaseItem {
            item_type: 'Augment';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: StatBlock;
        }

        interface GadgetItem extends BaseItem {
            item_type: 'Gadget';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: StatBlock;
        }

        interface QuestItem extends BaseItem {
            item_type: 'Quest Item';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: StatBlock;
        }

        interface CosmeticItem extends BaseItem {
            item_type: 'Cosmetic';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: StatBlock;
        } 

        interface MiscItem extends BaseItem {
            item_type: 'Misc';
            ammo_type: null | '';
            subcategory: null | '';
            stat_block: Pick<StatBlock,
                'range' | 'damage' | 'health' | 'radius' | 'shield' | 'weight' |
                'agility' | 'arcStun' | 'healing' | 'stamina' | 'stealth' |
                'useTime' | 'duration' | 'fireRate' | 'stability' | 'stackSize' |
                'damageMult' | 'raiderStun' | 'weightLimit' | 'augmentSlots' |
                'healingSlots' | 'magazineSize' | 'reducedNoise' | 'shieldCharge' |
                'backpackSlots' | 'quickUseSlots' | 'damagePerSecond' |
                'movementPenalty' | 'safePocketSlots' | 'damageMitigation' |
                'healingPerSecond' | 'reducedEquipTime' | 'staminaPerSecond' |
                'increasedADSSpeed' | 'increasedFireRate' | 'reducedReloadTime' |
                'illuminationRadius' | 'increasedEquipTime' | 'reducedUnequipTime' |
                'shieldCompatibility' | 'increasedUnequipTime' | 'reducedVerticalRecoil' |
                'increasedBulletVelocity' | 'increasedVerticalRecoil' | 'reducedMaxShotDispersion' |
                'reducedPerShotDispersion' | 'reducedDurabilityBurnRate' | 'reducedRecoilRecoveryTime' |
                'increasedRecoilRecoveryTime' | 'reducedDispersionRecoveryTime'
            >;
        }

        type ARCItem = WeaponItem 
            | ConsumableItem 
            | QuickUseItem 
            | ThrowableItem 
            | AmmunitionItem
            | ModificationItem 
            | BlueprintItem 
            | ShieldItem 
            | AugmentItem 
            | GadgetItem
            | KeyItem 
            | QuestItem
            | CosmeticItem
            | TopsideMaterialItem 
            | RefinedMaterialItem 
            | AdvancedMaterialItem 
            | BasicMaterialItem
            | RecyclableItem 
            | NatureItem 
            | TrinketItem 
            | MiscItem;

        interface APIResponse {
            data: Array<ARCItem>;
            maxValue: number;
            pagination: {
                page: number;
                limit: number;
                total: number;
                totalPages: number;
                hasNextPage: boolean;
                hasPrevPage: boolean;
            };
        }
    }
}

export { };
### CODEDIGEST_END ###

